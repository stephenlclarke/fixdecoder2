// SPDX-License-Identifier: AGPL-3.0-only
// SPDX-FileCopyrightText: 2025 Steve Clarke <stephenlclarke@mac.com> - https://xyzzy.tools

use anyhow::{Context, Result};
use quick_xml::de::from_str;
use regex::Regex;
use serde::Deserialize;
use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() -> Result<()> {
    run()
}

fn run() -> Result<()> {
    let repo_root = find_repo_root()?;
    let resources_dir = repo_root.join("resources");
    if !resources_dir.is_dir() {
        return Err(anyhow::anyhow!(
            "resources directory not found at {}",
            resources_dir.display()
        ));
    }

    let xml_paths = collect_xml_paths(&resources_dir)?;
    if xml_paths.is_empty() {
        return Err(anyhow::anyhow!(
            "no FIX XML files found under {}",
            resources_dir.display()
        ));
    }

    let fields = load_fields(&xml_paths)?;
    let sensitive = filter_sensitive(&fields);
    if sensitive.is_empty() {
        return Err(anyhow::anyhow!(
            "no sensitive tags detected (check regex/patterns)"
        ));
    }

    let dest = repo_root.join("src/fix/sensitive.rs");
    write_output(&dest, &sensitive)?;

    println!(
        "Generated {} with {} tags",
        dest.strip_prefix(&repo_root)
            .map(|p| p.display().to_string())
            .unwrap_or_else(|_| dest.display().to_string()),
        sensitive.len()
    );

    Ok(())
}

fn find_repo_root() -> Result<PathBuf> {
    let start = env::current_dir()?;
    let mut dir = start.clone();
    loop {
        if dir.join("Cargo.toml").is_file() && dir.join("resources").is_dir() {
            return Ok(dir);
        }
        match dir.parent() {
            Some(parent) => dir = parent.to_path_buf(),
            None => {
                return Err(anyhow::anyhow!(
                    "could not locate repo root starting at {}",
                    start.display()
                ));
            }
        }
    }
}

fn collect_xml_paths(resources_dir: &Path) -> Result<Vec<PathBuf>> {
    let mut files = Vec::new();
    for entry in fs::read_dir(resources_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map(|ext| ext == "xml").unwrap_or(false) {
            files.push(path);
        }
    }
    files.sort();
    Ok(files)
}

fn load_fields(paths: &[PathBuf]) -> Result<BTreeMap<u32, String>> {
    let mut fields = BTreeMap::new();
    for path in paths {
        let data = fs::read_to_string(path)
            .with_context(|| format!("failed to read {}", path.display()))?;
        let root: FixFieldsRoot =
            from_str(&data).with_context(|| format!("failed to parse {}", path.display()))?;
        for field in root.fields.field {
            fields.entry(field.number).or_insert(field.name);
        }
    }
    Ok(fields)
}

fn filter_sensitive(all_fields: &BTreeMap<u32, String>) -> BTreeMap<u32, String> {
    let pattern = Regex::new(r"(?i)(CompID|SubID|LocationID|Username|Password|Account)")
        .expect("valid regex");
    all_fields
        .iter()
        .filter_map(|(tag, name)| {
            if pattern.is_match(name) {
                Some((*tag, name.clone()))
            } else {
                None
            }
        })
        .collect()
}

fn write_output(path: &Path, tags: &BTreeMap<u32, String>) -> Result<()> {
    let mut content = String::from(
        "\
// Code generated by fixdecoder from QuickFIX XML specs. DO NOT EDIT.\n\
//\n\
// SPDX-License-Identifier: AGPL-3.0-only\n\
// SPDX-FileCopyrightText: 2025 Steve Clarke stephenlclarke@mac.com - https://xyzzy.tools\n\
//\n\
// This file is generated from FIX protocol XML specifications published by the\n\
// QuickFIX project: https://github.com/quickfix/quickfix/tree/master/spec\n\
// The QuickFIX specifications are licensed under the BSD 2-Clause License.\n\
// Copyright (c) 2001-2015 QuickFIX. All rights reserved.\n\
//\n\
// The full BSD 2-Clause notice for the QuickFIX materials is included in this\n\
// repositoryâ€™s NOTICE file. This generated file is part of fixdecoder (AGPL-3.0).\n\
\n\
//! Automatically generated by `cargo run --bin generate_sensitive_tags`\n\
use once_cell::sync::Lazy;\n\
use std::collections::BTreeMap;\n\n\
pub static SENSITIVE_TAG_NAMES: Lazy<BTreeMap<u32, &'static str>> = Lazy::new(|| {\n\
    let mut map = BTreeMap::new();\n",
    );
    for (tag, name) in tags {
        content.push_str(&format!("    map.insert({tag}, \"{name}\");\n"));
    }
    content.push_str("    map\n");
    content.push_str("});\n");

    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(path, content)?;
    Ok(())
}

#[derive(Debug, Deserialize)]
struct FixFieldsRoot {
    #[serde(rename = "fields")]
    fields: FixFieldList,
}

#[derive(Debug, Deserialize)]
struct FixFieldList {
    #[serde(rename = "field", default)]
    field: Vec<FixField>,
}

#[derive(Debug, Deserialize)]
struct FixField {
    #[serde(rename = "@number")]
    number: u32,
    #[serde(rename = "@name")]
    name: String,
}
